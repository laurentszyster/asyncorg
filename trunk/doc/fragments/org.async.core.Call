<div class="javaClass"><h2>Call</h2><p>Practical asynchronous continuations, kinda coroutine meets closures
 in a Java loop. Slowly, unobviously and yet damn practical in I/O bound
 stateful network applications experiencing high levels of concurrency and 
 latency between processes.</p><h3>Synopsis</h3><p>The purpose of <code>Call</code> is to program workflows of 
 concurrent I/O-bound processes, passing a current state to each
 continuations.</p><pre>...</pre><h3>Practical coroutines for I/O bound processes</h3><p>Network workflow are statefull processes which depend on I/O. They 
 spend most of their time waiting for some input to complete or some 
 output to start. The combination of fast non-blocking I/O and slow 
 continuations interleaved in one asynchronous loop is simple enough to run 
 as fast and reliably as statefull entreprise workflow applications demand.</p><p>By name and purpose <code>Call</code> looks like an ugly implementation 
 of LISP's <a href="http://community.schemewiki.org/?call-with-current-continuation">call/cc</a>. Here it is piggy-backed on the simplest behaviour of the  
 expected from a JVM's garbage collector, but it does nevertheless provides 
 practical coroutines to <code>org.async</code> applications (and for 
 nothing else, I'm afraid).</p></div>