<div class="javaClass"><h2>FileClassLoader</h2><p>A really simple class file loader, for applications that need to reload
 simple parts or restrict loadable classes to a filesystem path.</p><div><h3><span class="javaConstructor public">FileClassLoader</span> (path)</h3><p>Create a new loader that reads byte class definition files from
 a given file system path.</p><dl><di><dt>Parameters</dt><dd><div class="parameter"><code>String</code> - <span>path</span> <span>to prefix class file names</span></div></dd></di></dl><pre>public final class ClassLoaderTest {
    public static final void main (String[] args) throws Throwable {
        Class cl = (new FileClassLoader(&quot;bin/&quot;)).findClass(
            &quot;org.async.tests.DispatcherTest&quot;
            ); 
        ((Function) cl.newInstance()).apply(args);
        Static.loop.dispatch();
    }
}</pre><hr></hr></div><h3>Note</h3><p>Don't even think about glorifying this into some kind of mighty
 be-all-do-all uberClassLoader. Production Java applications are not 
 actually expected to reload their classes bytecodes, they are supposed 
 to JIT that once for all. And when they do demand reloadable classes, 
 a configurable filesystem restriction is all you will ever practically 
 use. Loading classes from the network, from a signed and compressed
 archive may sound cool but have little practical use in case of reload.</p><p>Reloading large JARs with many dependicies is a recipe for worse than 
 failure. Restart the JVM instead.</p><p>Loading bytecode from the network open the door for too many exploit.
 Instead, use SVN to update the application's components.</p></div>